ディレクティブの構造
v-bind:value.sync="message"
v-bind ディレクティブ
:value 引数
.sync 修飾子
"message" 値(Javascriptの式)


node.jsを組み合わせることでCSSもvueファイルにまとめることが出来る
Awesome VueやVue Curated、Elementには豊富なコンポーネントが用意されておりそれらを組み合わせることでVueに適したUIを作成することが出来る。



Vueインスタンスの作成
let app = new Vue({
    //オプション
})
コンストラクタ関数Vueを使ってVueインスタンスを作成
返り値はルートのインスタンスになっていて、変数化しておくことでコンソールからもアクセス出来る。

{{}}
v-for in]


p40
handleClick: function (event) {
            alert(event.target);
        }
//[object HTMLButtonElement]
これの引数eventの意味がわからず。
ただbutton属性がターゲットということはわかる。


p41
.number修飾子で受け取る値を数値として受け取ることができる。
v-ifでtrueだった場合は表示される
下記をv-on:clickに仕込めばtrue、falseの反転が可能になる
ifBool: function () {
            this.show = !this.show;
        }

transitionタグで囲ったものにCSSアニメーションを仕込むことが出来る


・Vueインスタンスのオプションの代表的な構成
・mountする要素（elはelementの略)要素と紐付けるセレクター
el:'#app',

・アプリケーションで使用するデータ
data: {
    message: 'Vue.js',
}

・算出プロパティ(dataと似たような扱いが可能で関数によって算出された値を返す)
computed: {
    computedMessage: function () {
        return this.message + '!'
    }
}

・ライフサイクルフック(インスタンス作成、リアクティブの初期化が終わった後に行われる処理)
created: function() {
    //行いたい処理
}

・アプリケーションで使用するメソッド
methods: {
    myMethod: function () {
        //処理
    }
}

・ライフサイクルフック(createdとは行われるタイミングが異なる)
mounted: {
    //メソッド
}

computedとmethodsの違いがよくわからず
methodsには値を保持する機能がなくcomputedには保持する機能があるということ?

p46
createdとmountedの違い
createdはインスタンス作成、リアクティブの初期化が終わった後に行われる処理だがDOMの作成はまだ完了していない。
mountedは


p53
dataオプション直下のプロパティは後から追加することが出来ないため、内容が決まっていなくても初期値や空データを用意しておく必要がある。

p56
テンプレート側のマスタッシュ構文内でもjavascript式を記述することは出来るが,
長く助長になってし編む場合は算出プロパティを使うべき
例
{{ message.length >= 10 ? '10文字以上' : '10文字未満' }}
下記はフィルタを使用したほうがいい(Chapter4)
{{ Math.round(3.14) }}


p57
属性タグ内ではマスタッシュ構文を使用した場合エスケープされてしまう。
タグ内に使用する場合はv-bindを使用する。


p58
v-bindディレクティブの修飾子propが理解できず。
少し理解できた

p61
thisのスコープ化
コールバック関数で使用されるthisではvueインスタンスを指すのではなくwindowを指してしまう。
その場合は予めthisを別の関数に定義し直す、アロー関数を使用等の対策を取る
ただしメソッド作成時にアロー関数を使用するとthisが使用できない
そのばあいはfunctionをつける。メソッドに()をつけて定義する等の対策が必要。


 p62
 v-bind:classは値がtrueの場合に反映されることになり、falseだと反映されない。
 表示したいクラスにハイフンを含む場合はシングルクオーテーションで囲む必要がある
v-bind:styleは値がそのまま反映される。

またすでにクラスやstyleが存在する場合は上書きやマージが行われる。

p63
v-bind:classに三項演算子を使う場合は配列リテラルを使用する。
<p v-bind:class="[isActive ? 'active' : 'normal', otherClass]"></p>
またdataオブジェクトで定義していた場合はそのまま渡すことも出来る
<p v-bind: class="classObject"></p>
data: {
    classObject: {
        child: true,
        'is-active': false
    }
}
これでテンプレートをスッキリさせることが出来る。

p64
画像等の情報をいっぺんにタグ内で展開しようとするとv-bindの数がかなり多くなってしまう。
このとき渡すオブジェクトのキーが要素、値が値になっていればまとめて渡すことができる。
<img v-bind="item" v-bind:id="'thumb-' + item.id">
上記のように後から特定の要素だけ変化させることもできる。


p67
v-ifとv-showの違い。
v-ifは条件がfalseだった場合コメントアウトされる。そもそものインスタンスが破棄されることになる。
v-showはdisplay:noneが追加されるだけでコードとしては残る。隠れているだけでそこに残っているので値などは保持されるし、リアクティブも生きている。
特定のdataを保持していないとエラーとなる場合はv-if。
ディレクティブが少なかったり、切り替え頻度が高く、残っていても平気な場合はv-show。

またv-ifのみtemplateにつけることが出来、グループ化させることができる。

p69
v-ifはv-else-ifやv-elseで条件分岐が可能。
ただしv-ifのグルーブ化を行った場合等は一意の属性として紐付けるためにkey属性をつけておくべきである。
トランジション等の挙動がおかしくなる場合がある。

p72
v-forでもkeyのをつけないとレンダリングやトランジションの挙動がおかしくなる。
またkeyがなかった場合は特定の動作で全ての項目に更新が走ってしまうが、keyをつけておけば特定の項目が編集されたときにその項目のみ処理が走ることになる。
keyにインデックス番号をつけると削除が行われた場合に全ての項目に走ってしまうので不変的な値を付ける。


p74
v-ifはtrue,falseで判定されるので式を入れることもできる。
下記はv-forで展開したときに、300を超えた場合非表示になる
v-if="item.price < 300"
しかしこの表示の場合だと〇〇件ヒットしました等のカウントに反映させることはできない。
上述のような処理は算出プロパティが適している。(chapter4)

p85
仮想DOMではなく直接DOMを参照する方法
DOMが生成された後に参照するためmounted以降で取得する必要がある。
this.$elで全体の参照。
ref="hello"このように名前を定義すれば
this.$refs.helloで参照できる。
v-if等で一度破棄してしまえば、たとえ値を更新最中であろうと仮想DOMに残っていなければdataの保持はできず消えてしまう。



p88
v-preディレクティブ
v-preを仕込んだタグ内ではマスタッシュ構文やディレクティブが効かなくなる。
完全な静的コンテンツに使用したり、XSS対策時に仕込んだりする。

v-onceディレクティブ
一度だけtemplateを評価するがそれ以降は静的なコンテンツとなる。
もしタグ内のプロパティに変化があっても反映されない。

v-textディレクティブ
タグ内がもし単一の{{}}で構成される場合はV-text="プロパティ"で省略することが出来る。

v-htmlディレクティブ
プロパティ内に属性が含まれる場合、HTMLタグとして認識して出力できる。
ただし信頼できるコンテンツに使用しないと悪用されてしまう可能性があるので注意。

v-cloak
インスタンス生成後に取り除かれる属性。
いきなり画面を描写してしまうとマスタッシュ構文がコンパイル前に表示されてしまう場合があるので、
v-cloak中は非表示にしたりLoading等の表示にしておく。


