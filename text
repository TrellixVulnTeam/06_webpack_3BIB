ディレクティブの構造
v-bind:value.sync="message"
v-bind ディレクティブ
:value 引数
.sync 修飾子
"message" 値(Javascriptの式)


node.jsを組み合わせることでCSSもvueファイルにまとめることが出来る
Awesome VueやVue Curated、Elementには豊富なコンポーネントが用意されておりそれらを組み合わせることでVueに適したUIを作成することが出来る。



Vueインスタンスの作成
let app = new Vue({
    //オプション
})
コンストラクタ関数Vueを使ってVueインスタンスを作成
返り値はルートのインスタンスになっていて、変数化しておくことでコンソールからもアクセス出来る。

{{}}
v-for in]


p40
handleClick: function (event) {
            alert(event.target);
        }
//[object HTMLButtonElement]
これの引数eventの意味がわからず。
ただbutton属性がターゲットということはわかる。


p41
.number修飾子で受け取る値を数値として受け取ることができる。
v-ifでtrueだった場合は表示される
下記をv-on:clickに仕込めばtrue、falseの反転が可能になる
ifBool: function () {
            this.show = !this.show;
        }

transitionタグで囲ったものにCSSアニメーションを仕込むことが出来る


・Vueインスタンスのオプションの代表的な構成
・mountする要素（elはelementの略)要素と紐付けるセレクター
el:'#app',

・アプリケーションで使用するデータ
data: {
    message: 'Vue.js',
}

・算出プロパティ(dataと似たような扱いが可能で関数によって算出された値を返す)
computed: {
    computedMessage: function () {
        return this.message + '!'
    }
}

・ライフサイクルフック(インスタンス作成、リアクティブの初期化が終わった後に行われる処理)
created: function() {
    //行いたい処理
}

・アプリケーションで使用するメソッド
methods: {
    myMethod: function () {
        //処理
    }
}

・ライフサイクルフック(createdとは行われるタイミングが異なる)
mounted: {
    //メソッド
}

computedとmethodsの違いがよくわからず
methodsには値を保持する機能がなくcomputedには保持する機能があるということ?

p46
createdとmountedの違い
createdはインスタンス作成、リアクティブの初期化が終わった後に行われる処理だがDOMの作成はまだ完了していない。
mountedは


p53
dataオプション直下のプロパティは後から追加することが出来ないため、内容が決まっていなくても初期値や空データを用意しておく必要がある。

p56
テンプレート側のマスタッシュ構文内でもjavascript式を記述することは出来るが,
長く助長になってし編む場合は算出プロパティを使うべき
例
{{ message.length >= 10 ? '10文字以上' : '10文字未満' }}
下記はフィルタを使用したほうがいい(Chapter4)
{{ Math.round(3.14) }}


p57
属性タグ内ではマスタッシュ構文を使用した場合エスケープされてしまう。
タグ内に使用する場合はv-bindを使用する。


p58
v-bindディレクティブの修飾子propが理解できず。
少し理解できた

p61
thisのスコープ化
コールバック関数で使用されるthisではvueインスタンスを指すのではなくwindowを指してしまう。
その場合は予めthisを別の関数に定義し直す、アロー関数を使用等の対策を取る
ただしメソッド作成時にアロー関数を使用するとthisが使用できない
そのばあいはfunctionをつける。メソッドに()をつけて定義する等の対策が必要。


 p62
 v-bind:classは値がtrueの場合に反映されることになり、falseだと反映されない。
 表示したいクラスにハイフンを含む場合はシングルクオーテーションで囲む必要がある
v-bind:styleは値がそのまま反映される。

またすでにクラスやstyleが存在する場合は上書きやマージが行われる。

p63
v-bind:classに三項演算子を使う場合は配列リテラルを使用する。
<p v-bind:class="[isActive ? 'active' : 'normal', otherClass]"></p>
またdataオブジェクトで定義していた場合はそのまま渡すことも出来る
<p v-bind: class="classObject"></p>
data: {
    classObject: {
        child: true,
        'is-active': false
    }
}
これでテンプレートをスッキリさせることが出来る。

p64
画像等の情報をいっぺんにタグ内で展開しようとするとv-bindの数がかなり多くなってしまう。
このとき渡すオブジェクトのキーが要素、値が値になっていればまとめて渡すことができる。
<img v-bind="item" v-bind:id="'thumb-' + item.id">
上記のように後から特定の要素だけ変化させることもできる。


p67
v-ifとv-showの違い。
v-ifは条件がfalseだった場合コメントアウトされる。そもそものインスタンスが破棄されることになる。
v-showはdisplay:noneが追加されるだけでコードとしては残る。隠れているだけでそこに残っているので値などは保持されるし、リアクティブも生きている。
特定のdataを保持していないとエラーとなる場合はv-if。
ディレクティブが少なかったり、切り替え頻度が高く、残っていても平気な場合はv-show。

またv-ifのみtemplateにつけることが出来、グループ化させることができる。

p69
v-ifはv-else-ifやv-elseで条件分岐が可能。
ただしv-ifのグルーブ化を行った場合等は一意の属性として紐付けるためにkey属性をつけておくべきである。
トランジション等の挙動がおかしくなる場合がある。

p72
v-forでもkeyのをつけないとレンダリングやトランジションの挙動がおかしくなる。
またkeyがなかった場合は特定の動作で全ての項目に更新が走ってしまうが、keyをつけておけば特定の項目が編集されたときにその項目のみ処理が走ることになる。
keyにインデックス番号をつけると削除が行われた場合に全ての項目に走ってしまうので不変的な値を付ける。


p74
v-ifはtrue,falseで判定されるので式を入れることもできる。
下記はv-forで展開したときに、300を超えた場合非表示になる
v-if="item.price < 300"
しかしこの表示の場合だと〇〇件ヒットしました等のカウントに反映させることはできない。
上述のような処理は算出プロパティが適している。(chapter4)

p85
仮想DOMではなく直接DOMを参照する方法
DOMが生成された後に参照するためmounted以降で取得する必要がある。
this.$elで全体の参照。
ref="hello"このように名前を定義すれば
this.$refs.helloで参照できる。
v-if等で一度破棄してしまえば、たとえ値を更新最中であろうと仮想DOMに残っていなければdataの保持はできず消えてしまう。



p88
v-preディレクティブ
v-preを仕込んだタグ内ではマスタッシュ構文やディレクティブが効かなくなる。
完全な静的コンテンツに使用したり、XSS対策時に仕込んだりする。

v-onceディレクティブ
一度だけtemplateを評価するがそれ以降は静的なコンテンツとなる。
もしタグ内のプロパティに変化があっても反映されない。

v-textディレクティブ
タグ内がもし単一の{{}}で構成される場合はV-text="プロパティ"で省略することが出来る。

v-htmlディレクティブ
プロパティ内に属性が含まれる場合、HTMLタグとして認識して出力できる。
ただし信頼できるコンテンツに使用しないと悪用されてしまう可能性があるので注意。

v-cloak
インスタンス生成後に取り除かれる属性。
いきなり画面を描写してしまうとマスタッシュ構文がコンパイル前に表示されてしまう場合があるので、
v-cloak中は非表示にしたりLoading等の表示にしておく。


chapter3

p96
@click="handleClick($event, item)
イベントオブジェクトまたはカスタムイベントの引数を$eventという変数名で使用できる
イベントオブジェクトの意味がわからず。
調べた結果上述のコードの場合はclickイベントに関しての情報をhandleClickメソッド内で展開出来るようになる


p98
通常inputなどはv-modelを使用すればdataプロパティと直結して反映できるが
あえてv-on:input等を使用すれば一度メソッドを通してからdataプロパティの更新が可能となる。

p100
.stop
イベントバブリングの停止
div v-on:click　の中にさらにv-on:clickが存在していた場合中をクリックした場合外(親)のイベントも一緒に発火してしまう
.stopを中(子)に設定すれば、子でイベント発火が止まる。

.prevent
発火はするがsubmitやリンク遷移等の処理のキャンセルを行う。

.capture
親に設定する修飾子で子が発火されたときでも、.captureがついている親から先に発火される。


p105
v-model
双方向バインディングを可能とするディレクティブ
瞬時に同期が可能になるが、日本語の場合に瞬時に同期させてい場合はv-on:inputのほうがいい。

p108
textareaはマスタッシュ構文が使用できないのでv-model又はV-bind:valueを使用する

単一要素のcheckboxの判定はtrue,falseで行われる。v-model="bool"
初期値がbool: trueの場合はすでにチェックが入っていることになり、チェックが外されるとfalseになる。
単一要素でも文字列判定を入れる場合はtrue-value, false-valueを設定する必要がある。

複数要素のcheckboxはv-model="val"この対象は同一でvalには空の配列を用意しておくことで
空の配列内に選択したcheckboxのvalueが収められる

radioボタンの値は文字列

selectboxは単一選択であれば文字列、複数選択できるならば空配列。


chapter4

p120
computed　算出プロパティ
処理を行った後のプロパティとして定義される。
{{ halfWidth }}でtemplateから使用可能
this.halfWidthでメソッドから使用可能。

p122
算出プロパティは基本的に元のデータに影響を与えず、プロパティに値を代入しようとしてもエラーとなる。
しかしcomputed関数にgetで取得した後にsetを定義すればdataプロパティに代入することができる。
halfWidth: {
            get: function () {
                return this.width / 2;
            },
            set: function (val) {
                this.width = val * 2
            }
        },

p123
大きな特徴として算出プロパティはリアクティブな依存データに基づき結果をキャッシュする
Math.random()を返すcomputedがあったとして、何度行ってもリアクティブなデータが絡まない限り同じ結果が返ってくる。
methodsではその計算を毎回行うため、結果は変わる。
